import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import { join, dirname } from 'node:path';
import { fileURLToPath } from 'node:url';
import readline from 'node:readline';
import { getAvailableLlms } from './llm-discovery.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);
const ENV_FILE_PATH = join(__dirname, '..', '.env');

function createReadlineInterface() {
	return readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});
}

function loadExistingEnv() {
	if (!existsSync(ENV_FILE_PATH)) {
		return {};
	}
	
	const content = readFileSync(ENV_FILE_PATH, 'utf8');
	const env = {};
	
	for (const line of content.split('\n')) {
		const trimmed = line.trim();
		if (trimmed && !trimmed.startsWith('#')) {
			const [key, ...valueParts] = trimmed.split('=');
			if (key && valueParts.length > 0) {
				env[key] = valueParts.join('=');
			}
		}
	}
	
	return env;
}

function saveEnvFile(envConfig) {
	const lines = [
		'# GitLab MR Reviewer Configuration',
		'# Generated by setup command',
		'',
		'# GitLab token for API access',
		`GITLAB_PRIVATE_TOKEN=${envConfig.GITLAB_PRIVATE_TOKEN || ''}`,
		'',
		'# Default settings (used when not specified via CLI)',
		`DEFAULT_REVIEW_MODE=${envConfig.DEFAULT_REVIEW_MODE || ''}`,
		`DEFAULT_LLM_PROVIDER=${envConfig.DEFAULT_LLM_PROVIDER || ''}`,
		`DEFAULT_OUTPUT_FORMAT=${envConfig.DEFAULT_OUTPUT_FORMAT || ''}`,
		`DEFAULT_LOCAL_OUTPUT_FORMAT=${envConfig.DEFAULT_LOCAL_OUTPUT_FORMAT || ''}`,
		'',
		'# Force settings (skip prompts entirely)',
		`FORCE_REVIEW_MODE=${envConfig.FORCE_REVIEW_MODE || ''}`,
		`FORCE_LLM_PROVIDER=${envConfig.FORCE_LLM_PROVIDER || ''}`,
		`FORCE_OUTPUT_FORMAT=${envConfig.FORCE_OUTPUT_FORMAT || ''}`,
		`FORCE_LOCAL_OUTPUT_FORMAT=${envConfig.FORCE_LOCAL_OUTPUT_FORMAT || ''}`,
		''
	];
	
	writeFileSync(ENV_FILE_PATH, lines.join('\n'));
}

async function promptWithDefault(rl, question, defaultValue = '', validOptions = null) {
	return new Promise((resolve) => {
		const prompt = defaultValue 
			? `${question} (current: ${defaultValue}): `
			: `${question}: `;
			
		rl.question(prompt, (answer) => {
			const value = answer.trim() || defaultValue;
			
			if (validOptions && value && !validOptions.includes(value)) {
				console.log(`Invalid option. Valid choices: ${validOptions.join(', ')}`);
				return promptWithDefault(rl, question, defaultValue, validOptions).then(resolve);
			}
			
			resolve(value);
		});
	});
}

async function promptYesNo(rl, question, defaultValue = false) {
	return new Promise((resolve) => {
		const defaultText = defaultValue ? 'Y/n' : 'y/N';
		rl.question(`${question} [${defaultText}]: `, (answer) => {
			const normalized = answer.trim().toLowerCase();
			if (normalized === '') {
				resolve(defaultValue);
			} else {
				resolve(normalized === 'y' || normalized === 'yes');
			}
		});
	});
}

export async function runSetup() {
	console.log('ðŸ”§ GitLab MR Reviewer Setup');
	console.log('Configure default preferences and force options.\n');
	
	const rl = createReadlineInterface();
	const existingEnv = loadExistingEnv();
	const newEnv = { ...existingEnv };
	
	try {
		// GitLab token
		console.log('1. GitLab Configuration');
		newEnv.GITLAB_PRIVATE_TOKEN = await promptWithDefault(
			rl, 
			'GitLab Private Token', 
			existingEnv.GITLAB_PRIVATE_TOKEN
		);
		
		console.log('\n2. Default Settings (used when option not specified)');
		
		// Review mode defaults
		newEnv.DEFAULT_REVIEW_MODE = await promptWithDefault(
			rl,
			'Default review mode',
			existingEnv.DEFAULT_REVIEW_MODE || 'local',
			['local', 'gitlab', '']
		);
		
		// LLM provider defaults
		const availableLlms = await getAvailableLlms();
		if (availableLlms.length > 0) {
			console.log(`Available LLMs: ${availableLlms.join(', ')}`);
			newEnv.DEFAULT_LLM_PROVIDER = await promptWithDefault(
				rl,
				'Default LLM provider',
				existingEnv.DEFAULT_LLM_PROVIDER || availableLlms[0],
				[...availableLlms, '']
			);
		}
		
		// Output format defaults
		newEnv.DEFAULT_OUTPUT_FORMAT = await promptWithDefault(
			rl,
			'Default output format (for GitLab mode)',
			existingEnv.DEFAULT_OUTPUT_FORMAT || 'gitlab',
			['gitlab', 'html', 'cli', '']
		);
		
		newEnv.DEFAULT_LOCAL_OUTPUT_FORMAT = await promptWithDefault(
			rl,
			'Default output format (for local mode)',
			existingEnv.DEFAULT_LOCAL_OUTPUT_FORMAT || 'html',
			['html', 'cli', '']
		);
		
		console.log('\n3. Force Settings (skip prompts entirely)');
		console.log('Leave empty to still show prompts with defaults above.\n');
		
		// Force options
		const configureForce = await promptYesNo(rl, 'Configure force settings to skip prompts?', false);
		
		if (configureForce) {
			newEnv.FORCE_REVIEW_MODE = await promptWithDefault(
				rl,
				'Force review mode (empty to keep prompts)',
				existingEnv.FORCE_REVIEW_MODE,
				['local', 'gitlab', '']
			);
			
			if (availableLlms.length > 0) {
				newEnv.FORCE_LLM_PROVIDER = await promptWithDefault(
					rl,
					'Force LLM provider (empty to keep prompts)',
					existingEnv.FORCE_LLM_PROVIDER,
					[...availableLlms, '']
				);
			}
			
			newEnv.FORCE_OUTPUT_FORMAT = await promptWithDefault(
				rl,
				'Force output format for GitLab mode (empty to keep prompts)',
				existingEnv.FORCE_OUTPUT_FORMAT,
				['gitlab', 'html', 'cli', '']
			);
			
			newEnv.FORCE_LOCAL_OUTPUT_FORMAT = await promptWithDefault(
				rl,
				'Force output format for local mode (empty to keep prompts)',
				existingEnv.FORCE_LOCAL_OUTPUT_FORMAT,
				['html', 'cli', '']
			);
		}
		
		// Save configuration
		saveEnvFile(newEnv);
		
		console.log('\nâœ… Configuration saved to .env');
		console.log('Your preferences will now be used as defaults in the CLI.\n');
		
	} catch (error) {
		console.error('Setup failed:', error.message);
		process.exit(1);
	} finally {
		rl.close();
	}
}