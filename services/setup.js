import { readFileSync, writeFileSync, existsSync } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import readline from 'node:readline';
import { getAvailableLlms } from './llm-discovery.js';

const __filename = fileURLToPath(import.meta.url),
	__dirname = path.dirname(__filename),
	ENV_FILE_PATH = path.join(__dirname, '..', '.env');

function createReadlineInterface() {
	return readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});
}

function loadExistingEnvironment() {
	if (!existsSync(ENV_FILE_PATH)) {
		return {};
	}

	const content = readFileSync(ENV_FILE_PATH, 'utf8'),
		environment = {};

	for (const line of content.split('\n')) {
		const trimmed = line.trim();
		if (trimmed && !trimmed.startsWith('#')) {
			const [key, ...valueParts] = trimmed.split('=');
			if (key && valueParts.length > 0) {
				environment[key] = valueParts.join('=');
			}
		}
	}

	return environment;
}

function saveEnvironmentFile(environmentConfig) {
	const lines = [
		'# GitLab MR Reviewer Configuration',
		'# Generated by setup command',
		'',
		'# GitLab token for API access',
		`GITLAB_PRIVATE_TOKEN=${environmentConfig.GITLAB_PRIVATE_TOKEN || ''}`,
		'',
		'# Default settings (used when not specified via CLI)',
		`DEFAULT_REVIEW_MODE=${environmentConfig.DEFAULT_REVIEW_MODE || ''}`,
		`DEFAULT_LLM_PROVIDER=${environmentConfig.DEFAULT_LLM_PROVIDER || ''}`,
		`DEFAULT_OUTPUT_FORMAT=${environmentConfig.DEFAULT_OUTPUT_FORMAT || ''}`,
		`DEFAULT_LOCAL_OUTPUT_FORMAT=${environmentConfig.DEFAULT_LOCAL_OUTPUT_FORMAT || ''}`,
		'',
		'# Force settings (skip prompts entirely)',
		`FORCE_REVIEW_MODE=${environmentConfig.FORCE_REVIEW_MODE || ''}`,
		`FORCE_LLM_PROVIDER=${environmentConfig.FORCE_LLM_PROVIDER || ''}`,
		`FORCE_OUTPUT_FORMAT=${environmentConfig.FORCE_OUTPUT_FORMAT || ''}`,
		`FORCE_LOCAL_OUTPUT_FORMAT=${environmentConfig.FORCE_LOCAL_OUTPUT_FORMAT || ''}`,
		'',
	];

	writeFileSync(ENV_FILE_PATH, lines.join('\n'));
}

async function promptWithDefault(rl, question, defaultValue = '', validOptions = null) {
	return new Promise((resolve) => {
		const prompt = defaultValue ?
			`${question} (current: ${defaultValue}): ` :
			`${question}: `;

		rl.question(prompt, (answer) => {
			const value = answer.trim() || defaultValue;

			if (validOptions && value && !validOptions.includes(value)) {
				console.log(`Invalid option. Valid choices: ${validOptions.join(', ')}`);
				return promptWithDefault(rl, question, defaultValue, validOptions).then(resolve);
			}

			resolve(value);
		});
	});
}

async function promptYesNo(rl, question, defaultValue = false) {
	return new Promise((resolve) => {
		const defaultText = defaultValue ? 'Y/n' : 'y/N';
		rl.question(`${question} [${defaultText}]: `, (answer) => {
			const normalized = answer.trim().toLowerCase();
			if (normalized === '') {
				resolve(defaultValue);
			} else {
				resolve(normalized === 'y' || normalized === 'yes');
			}
		});
	});
}

export async function runSetup() {
	console.log('ðŸ”§ GitLab MR Reviewer Setup');
	console.log('Configure default preferences and force options.\n');

	const rl = createReadlineInterface(),
		existingEnvironment = loadExistingEnvironment(),
		newEnvironment = { ...existingEnvironment };

	try {
		// GitLab token
		console.log('1. GitLab Configuration');
		newEnvironment.GITLAB_PRIVATE_TOKEN = await promptWithDefault(
			rl,
			'GitLab Private Token',
			existingEnvironment.GITLAB_PRIVATE_TOKEN,
		);

		console.log('\n2. Default Settings (used when option not specified)');

		// Review mode defaults
		newEnvironment.DEFAULT_REVIEW_MODE = await promptWithDefault(
			rl,
			'Default review mode',
			existingEnvironment.DEFAULT_REVIEW_MODE || 'local',
			['local', 'gitlab', ''],
		);

		// LLM provider defaults
		const availableLlms = await getAvailableLlms();
		if (availableLlms.length > 0) {
			console.log(`Available LLMs: ${availableLlms.join(', ')}`);
			newEnvironment.DEFAULT_LLM_PROVIDER = await promptWithDefault(
				rl,
				'Default LLM provider',
				existingEnvironment.DEFAULT_LLM_PROVIDER || availableLlms[0],
				[...availableLlms, ''],
			);
		}

		// Output format defaults
		newEnvironment.DEFAULT_OUTPUT_FORMAT = await promptWithDefault(
			rl,
			'Default output format (for GitLab mode)',
			existingEnvironment.DEFAULT_OUTPUT_FORMAT || 'gitlab',
			['gitlab', 'html', 'cli', ''],
		);

		newEnvironment.DEFAULT_LOCAL_OUTPUT_FORMAT = await promptWithDefault(
			rl,
			'Default output format (for local mode)',
			existingEnvironment.DEFAULT_LOCAL_OUTPUT_FORMAT || 'html',
			['html', 'cli', ''],
		);

		console.log('\n3. Force Settings (skip prompts entirely)');
		console.log('Leave empty to still show prompts with defaults above.\n');

		// Force options
		const configureForce = await promptYesNo(rl, 'Configure force settings to skip prompts?', false);

		if (configureForce) {
			newEnvironment.FORCE_REVIEW_MODE = await promptWithDefault(
				rl,
				'Force review mode (empty to keep prompts)',
				existingEnvironment.FORCE_REVIEW_MODE,
				['local', 'gitlab', ''],
			);

			if (availableLlms.length > 0) {
				newEnvironment.FORCE_LLM_PROVIDER = await promptWithDefault(
					rl,
					'Force LLM provider (empty to keep prompts)',
					existingEnvironment.FORCE_LLM_PROVIDER,
					[...availableLlms, ''],
				);
			}

			newEnvironment.FORCE_OUTPUT_FORMAT = await promptWithDefault(
				rl,
				'Force output format for GitLab mode (empty to keep prompts)',
				existingEnvironment.FORCE_OUTPUT_FORMAT,
				['gitlab', 'html', 'cli', ''],
			);

			newEnvironment.FORCE_LOCAL_OUTPUT_FORMAT = await promptWithDefault(
				rl,
				'Force output format for local mode (empty to keep prompts)',
				existingEnvironment.FORCE_LOCAL_OUTPUT_FORMAT,
				['html', 'cli', ''],
			);
		}

		// Save configuration
		saveEnvironmentFile(newEnvironment);

		console.log('\nâœ… Configuration saved to .env');
		console.log('Your preferences will now be used as defaults in the CLI.\n');
	} catch (error) {
		console.error('Setup failed:', error.message);
		process.exit(1);
	} finally {
		rl.close();
	}
}
