import 'dotenv/config';
import { Command } from 'commander';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';
import readline from 'node:readline';
import { getProjectCloneUrl, getMergeRequestDetails, getMergeRequestDiff, getChangedFiles, getUnresolvedDiscussions, postCommentToMergeRequest, postLineCommentToMergeRequest } from './api/gitlab.js';
import { cloneRepository } from './services/git.js';
import { runCodeReview } from './services/llm.js';
import { createTemporaryDirectory, cleanupDirectory, readFilesForContext } from './utils/file-handler.js';
import config from './config.js';
import { readFileSync, writeFileSync } from 'node:fs';
import { fileURLToPath } from 'node:url';
import path from 'node:path';

const __filename = fileURLToPath(import.meta.url),
	__dirname = path.dirname(__filename),
	packageJson = JSON.parse(readFileSync(path.join(__dirname, 'package.json'), 'utf8')),

	execPromise = promisify(exec);

async function promptForUrl() {
	const rl = readline.createInterface({
		input: process.stdin,
		output: process.stdout,
	});

	return new Promise((resolve) => {
		rl.question('Please enter the GitLab Merge Request URL: ', (answer) => {
			rl.close();
			resolve(answer.trim());
		});
	});
}

async function checkBinaryExists(binaryName) {
	try {
		await execPromise(`command -v ${binaryName}`);
		return true;
	} catch {
		return false;
	}
}

async function getAvailableLlms() {
	const availableLlms = [];

	for (const [llmName, llmConfig] of Object.entries(config.llms)) {
		const exists = await checkBinaryExists(llmConfig.cliPath);
		if (exists) {
			availableLlms.push(llmName);
		}
	}

	return availableLlms;
}

function generateHtmlReport(parsedReview, llmChoice) {
	const html = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Review Report - ${llmChoice.toUpperCase()}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f8fafc; color: #1e293b; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .header { background: white; border-radius: 8px; padding: 24px; margin-bottom: 24px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .title { font-size: 24px; font-weight: 600; margin-bottom: 8px; color: #0f172a; }
        .subtitle { color: #64748b; font-size: 14px; }
        .summary { background: white; border-radius: 8px; padding: 24px; margin-bottom: 24px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }
        .summary h2 { font-size: 18px; margin-bottom: 16px; color: #0f172a; }
        .summary-text { line-height: 1.6; color: #334155; }
        .comments-section h2 { font-size: 18px; margin-bottom: 16px; color: #0f172a; }
        .comment { background: white; border-radius: 8px; padding: 20px; margin-bottom: 16px; box-shadow: 0 1px 3px rgba(0,0,0,0.1); border-left: 4px solid #e2e8f0; }
        .comment.issue { border-left-color: #ef4444; }
        .comment.suggestion { border-left-color: #3b82f6; }
        .comment.todo { border-left-color: #f59e0b; }
        .comment.praise { border-left-color: #10b981; }
        .comment.question { border-left-color: #8b5cf6; }
        .comment.nitpick { border-left-color: #6b7280; }
        .comment-header { display: flex; align-items: center; margin-bottom: 12px; }
        .file-path { font-family: 'SF Mono', Consolas, monospace; font-size: 14px; color: #059669; font-weight: 500; }
        .line-number { background: #f1f5f9; color: #475569; padding: 2px 8px; border-radius: 4px; font-family: 'SF Mono', Consolas, monospace; font-size: 12px; margin-left: 12px; }
        .comment-text { line-height: 1.6; color: #334155; }
        .label { display: inline-block; padding: 2px 8px; border-radius: 12px; font-size: 12px; font-weight: 500; margin-right: 8px; }
        .label.issue { background: #fef2f2; color: #dc2626; }
        .label.suggestion { background: #eff6ff; color: #2563eb; }
        .label.todo { background: #fffbeb; color: #d97706; }
        .label.praise { background: #ecfdf5; color: #059669; }
        .label.question { background: #f3f4f6; color: #7c3aed; }
        .label.nitpick { background: #f9fafb; color: #4b5563; }
        .stats { display: flex; gap: 16px; margin-top: 16px; }
        .stat { background: #f8fafc; padding: 8px 16px; border-radius: 6px; text-align: center; }
        .stat-number { font-size: 18px; font-weight: 600; color: #0f172a; }
        .stat-label { font-size: 12px; color: #64748b; margin-top: 2px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="title">Code Review Report</div>
            <div class="subtitle">Generated by ${llmChoice.toUpperCase()} • ${new Date().toLocaleString()}</div>
            <div class="stats">
                <div class="stat">
                    <div class="stat-number">${parsedReview.comments.length}</div>
                    <div class="stat-label">Comments</div>
                </div>
                <div class="stat">
                    <div class="stat-number">${parsedReview.comments.filter(c => c.comment.includes('issue (blocking)')).length}</div>
                    <div class="stat-label">Blocking Issues</div>
                </div>
                <div class="stat">
                    <div class="stat-number">${parsedReview.comments.filter(c => c.comment.includes('praise')).length}</div>
                    <div class="stat-label">Praise</div>
                </div>
            </div>
        </div>
        
        <div class="summary">
            <h2>Summary</h2>
            <div class="summary-text">${parsedReview.summary}</div>
        </div>
        
        <div class="comments-section">
            <h2>Detailed Comments</h2>
            ${parsedReview.comments.map((comment) => {
				const labelMatch = comment.comment.match(/^(\w+)(\s*\([^)]+\))?:/),
					label = labelMatch ? labelMatch[1] : 'note',
					commentText = comment.comment.replace(/^(\w+)(\s*\([^)]+\))?:\s*/, '');
				return `
                <div class="comment ${label}">
                    <div class="comment-header">
                        <span class="label ${label}">${label}</span>
                        <span class="file-path">${comment.file}</span>
                        <span class="line-number">Line ${comment.line}</span>
                    </div>
                    <div class="comment-text">${commentText}</div>
                </div>`;
			}).join('')}
        </div>
    </div>
</body>
</html>`;
	return html;
}

function outputCliFormat(parsedReview, llmChoice) {
	console.log(`\n${llmChoice.toUpperCase()} Code Review Results:\n`);
	console.log(parsedReview.summary);
	console.log('\nIssues found:\n');

	if (parsedReview.comments.length === 0) {
		console.log('  No issues found.');
		return;
	}

	for (const comment of parsedReview.comments) {
		const labelMatch = comment.comment.match(/^(\w+)(\s*\([^)]+\))?:/),
			label = labelMatch ? labelMatch[0] : 'note:',
			commentText = comment.comment.replace(/^(\w+)(\s*\([^)]+\))?:\s*/, '');

		console.log(`  ${comment.file}:${comment.line} ${label} ${commentText}`);
	}

	const blockingIssues = parsedReview.comments.filter(c => c.comment.includes('(blocking)')).length,
		suggestions = parsedReview.comments.filter(c => c.comment.includes('suggestion')).length;

	console.log(`\nSummary: ${parsedReview.comments.length} comments (${blockingIssues} blocking, ${suggestions} suggestions)\n`);
}

function parseGitLabUrl(url) {
	try {
		const urlObject = new URL(url),
			pathParts = urlObject.pathname.split('/').filter(Boolean),

			mrIndex = pathParts.indexOf('merge_requests');
		if (mrIndex === -1 || mrIndex + 1 >= pathParts.length) {
			throw new Error('Invalid Merge Request URL format.');
		}

		const mergeRequestIid = Number.parseInt(pathParts[mrIndex + 1]),
			projectPath = pathParts.slice(0, mrIndex - 1).join('/'),
			projectId = encodeURIComponent(projectPath),
			gitlabUrl = urlObject.origin;

		return { gitlabUrl, projectId, mergeRequestIid };
	} catch (error) {
		throw new Error(`Failed to parse GitLab URL: ${error.message}`);
	}
}

async function performReview(mrUrl, llmChoice, outputFormat = 'gitlab') {
	if (!process.env.GITLAB_PRIVATE_TOKEN) {
		throw new Error(
			'GITLAB_PRIVATE_TOKEN environment variable is not set. Please set it to your GitLab private token.',
		);
	}

	let temporaryDirectory = null;

	try {
		// Check available LLMs
		const availableLlms = await getAvailableLlms();

		if (availableLlms.length === 0) {
			throw new Error('No LLM binaries found. Please install Claude CLI or Gemini CLI.');
		}

		// Validate LLM choice
		if (llmChoice && !availableLlms.includes(llmChoice.toLowerCase())) {
			throw new Error(`Invalid LLM choice "${llmChoice}". Available options: ${availableLlms.join(', ')}`);
		}

		// Auto-select LLM if not provided
		if (!llmChoice) {
			if (availableLlms.length === 1) {
				llmChoice = availableLlms[0];
				console.log(`Using ${llmChoice} (only available LLM)`);
			} else {
				llmChoice = availableLlms[0]; // Default to first available
				console.log(`Using ${llmChoice} (default LLM)`);
			}
		}

		const { gitlabUrl, projectId, mergeRequestIid } = parseGitLabUrl(mrUrl);

		console.log(`Fetching details for MR !${mergeRequestIid} in project ${projectId}...`);

		const mrDetails = await getMergeRequestDetails(gitlabUrl, projectId, mergeRequestIid),
			sourceBranch = mrDetails.source_branch,
			baseSha = mrDetails.diff_refs.base_sha,
			startSha = mrDetails.diff_refs.start_sha,
			headSha = mrDetails.diff_refs.head_sha;
		console.log(`✓ Found MR: "${mrDetails.title}" on branch "${sourceBranch}"`);
		console.log(`✓ SHA references - base: ${baseSha.slice(0, 8)}, start: ${startSha.slice(0, 8)}, head: ${headSha.slice(0, 8)}`);

		console.log('Checking for unresolved discussions...');
		const unresolvedDiscussions = await getUnresolvedDiscussions(gitlabUrl, projectId, mergeRequestIid);

		if (unresolvedDiscussions.length > 0) {
			console.log(`\n❌ Cannot proceed with code review:`);
			console.log(`Found ${unresolvedDiscussions.length} unresolved discussion(s) on this MR.`);
			console.log(`\nPlease resolve all discussions before running the code review.`);
			console.log(`\nUnresolved discussions:`);

			for (const [index, discussion] of unresolvedDiscussions.entries()) {
				const firstNote = discussion.notes[0],
					author = firstNote.author.name,
					snippet = firstNote.body.slice(0, 100) + (firstNote.body.length > 100 ? '...' : '');
				console.log(`  ${index + 1}. By ${author}: ${snippet}`);
			}

			return;
		}

		console.log(`✓ No unresolved discussions found`);

		const cloneUrl = await getProjectCloneUrl(gitlabUrl, projectId);
		temporaryDirectory = await createTemporaryDirectory();
		console.log(`✓ Created temporary directory: ${temporaryDirectory}`);

		console.log(`Cloning repository into ${temporaryDirectory}...`);
		await cloneRepository(cloneUrl, sourceBranch, temporaryDirectory);
		console.log('✓ Repository cloned successfully');

		console.log('Fetching MR diff and changed files...');
		const diff = await getMergeRequestDiff(gitlabUrl, projectId, mergeRequestIid),
			changedFiles = await getChangedFiles(gitlabUrl, projectId, mergeRequestIid);
		console.log(`✓ Found ${changedFiles.length} changed files, diff size: ${diff.length} characters`);

		console.log('Reading changed files for context...');
		const fileContext = await readFilesForContext(changedFiles, temporaryDirectory);
		console.log(`✓ File context prepared, total size: ${fileContext.length} characters`);

		console.log(`Running ${llmChoice.toUpperCase()} code review...`);
		const startTime = Date.now(),
			review = await runCodeReview(llmChoice, diff, fileContext),
			endTime = Date.now();
		console.log(`✓ ${llmChoice.toUpperCase()} code review completed in ${(endTime - startTime) / 1000}s`);

		let parsedReview;
		try {
			// Clean up the response - extract JSON from the response
			let cleanedReview = review.trim();

			// First, try to parse as Claude CLI's wrapped response format
			if (llmChoice.toLowerCase() === 'claude' && cleanedReview.startsWith('{') && cleanedReview.includes('"result"')) {
				const wrappedResponse = JSON.parse(cleanedReview);
				if (wrappedResponse.result) {
					cleanedReview = wrappedResponse.result;
				}
			}

			// Look for JSON block markers
			const jsonStart = cleanedReview.indexOf('```json'),
				jsonEnd = cleanedReview.lastIndexOf('```');

			if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
				// Extract JSON from between ```json and ```
				cleanedReview = cleanedReview.slice(jsonStart + 7, jsonEnd).trim();
			} else {
				// Try to find JSON object by looking for { and }
				const firstBrace = cleanedReview.indexOf('{'),
					lastBrace = cleanedReview.lastIndexOf('}');
				if (firstBrace !== -1 && lastBrace !== -1 && lastBrace > firstBrace) {
					cleanedReview = cleanedReview.slice(firstBrace, lastBrace + 1);
				}
			}

			parsedReview = JSON.parse(cleanedReview);
		} catch {
			console.error(`Failed to parse ${llmChoice} review as JSON. Raw output:`, review);
			throw new Error(`Invalid JSON response from ${llmChoice} CLI.`);
		}

		// Handle different output formats
		if (outputFormat === 'html') {
			const html = generateHtmlReport(parsedReview, llmChoice),
				fileName = `code-review-${Date.now()}.html`;
			writeFileSync(fileName, html);
			console.log(`\n✓ HTML report generated: ${fileName}`);
			console.log(`\nSummary: ${parsedReview.comments.length} comments found`);
		} else if (outputFormat === 'cli') {
			outputCliFormat(parsedReview, llmChoice);
		} else {
			// Default GitLab output
			console.log(`\n--- ${llmChoice.toUpperCase()} Code Review Summary ---\n`);
			console.log(parsedReview.summary);

			console.log(`\nPosting ${parsedReview.comments.length} comments to Merge Request...`);
			let successfulComments = 0,
				failedComments = 0;

			for (const comment of parsedReview.comments) {
				try {
					await postLineCommentToMergeRequest(
						gitlabUrl,
						projectId,
						mergeRequestIid,
						comment.comment,
						comment.file,
						comment.line,
						baseSha,
						startSha,
						headSha,
					);
					console.log(`✓ Posted comment to ${comment.file}:${comment.line}`);
					successfulComments++;
				} catch (commentError) {
					console.error(
						`✗ Failed to post comment to ${comment.file}:${comment.line}:`,
						commentError.message,
					);
					failedComments++;
				}
			}

			console.log(`Comment posting complete: ${successfulComments} successful, ${failedComments} failed`);

			console.log('Posting summary comment...');
			await postCommentToMergeRequest(
				gitlabUrl,
				projectId,
				mergeRequestIid,
				`## ${llmChoice.toUpperCase()} Code Review Summary\n\n${parsedReview.summary}`,
			);
			console.log('✓ Summary comment posted successfully.');
		}
	} catch (error) {
		console.error('\nAn error occurred:', error.message);
		process.exit(1);
	} finally {
		if (temporaryDirectory) {
			await cleanupDirectory(temporaryDirectory);
		}
	}
}

// Commander CLI setup
const program = new Command();

program
	.name('gitlab-mr-reviewer')
	.description('Automated GitLab MR code reviews using various LLM providers')
	.version(packageJson.version);

program
	.command('review')
	.description('Review a GitLab Merge Request')
	.argument('[url]', 'GitLab Merge Request URL')
	.option('-l, --llm <provider>', 'LLM provider to use (auto-detected if not specified)')
	.option('-o, --output <format>', 'Output format: gitlab, html, cli', 'gitlab')
	.option('--list-llms', 'List available LLM providers and exit')
	.action(async(url, options) => {
		if (options.listLlms) {
			const availableLlms = await getAvailableLlms();
			if (availableLlms.length === 0) {
				console.log('No LLM binaries found. Please install one of: claude, gemini, openai, ollama, chatgpt, llama, or gh (for copilot)');
			} else {
				console.log('Available LLM providers:');
				for (const llm of availableLlms) {
					console.log(`  - ${llm}`);
				}
			}
			return;
		}

		// Validate output format
		if (!['gitlab', 'html', 'cli'].includes(options.output)) {
			console.error('Error: Invalid output format. Choose from: gitlab, html, cli');
			process.exit(1);
		}

		if (!url) {
			url = await promptForUrl();
			if (!url) {
				console.error('Error: URL is required');
				process.exit(1);
			}
		}

		await performReview(url, options.llm, options.output);
	});

// Add a separate command for listing LLMs
program
	.command('list-llms')
	.description('List available LLM providers')
	.action(async() => {
		const availableLlms = await getAvailableLlms();
		if (availableLlms.length === 0) {
			console.log('No LLM binaries found. Please install one of: claude, gemini, openai, ollama, chatgpt, llama, or gh (for copilot)');
		} else {
			console.log('Available LLM providers:');
			for (const llm of availableLlms) {
				console.log(`  - ${llm}`);
			}
		}
	});

// Interactive mode when no arguments provided
if (process.argv.length === 2) {
	const url = await promptForUrl();
	if (!url) {
		console.error('Error: URL is required');
		process.exit(1);
	}
	await performReview(url, undefined, 'gitlab');
} else {
	program.parse();
}
